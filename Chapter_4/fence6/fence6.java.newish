/*
ID: 100021881
LANG: JAVA
PROG: fence6
*/

import java.io.*;
import java.util.*;
import java.util.stream.*;

/**
 * find the minimum perimeter given a set of edges
 * @author  Johan Vonk <johan.d.s.vonk@gmail.com>
 */
public class fence6 {
    public static Edge[] edges;
    public static int N;
    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        BufferedReader br = new BufferedReader(new FileReader("fence6.in"));
        N = Integer.parseInt(br.readLine());
        edges = new Edge[N + 1];
        for(int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int id = Integer.parseInt(st.nextToken())-1;
            int len = Integer.parseInt(st.nextToken());
            Set<Integer> set1 = new HashSet<Integer>();
            st = new StringTokenizer(br.readLine());
            while(st.hasMoreTokens()) {
                set1.add(Integer.parseInt(st.nextToken())-1);
            }
            Set<Integer> set2 = new HashSet<Integer>();
            st = new StringTokenizer(br.readLine());
            while(st.hasMoreTokens()) {
                set2.add(Integer.parseInt(st.nextToken())-1);
            }
            edges[id] = new Edge(len, set1, set2);
            System.out.println(id+"\t"+set1+"\t"+set2);
        }

        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("fence6.out")));
        out.println(solve());
        out.close();
        System.out.println(System.currentTimeMillis() - startTime);
        System.exit(0);
    }
    public static int solve() {
        int min = Integer.MAX_VALUE;
        for(int start = 0; start < N; start++) {
            boolean[][] visited = new boolean[N][2];
            for(int dir = 0; dir <= 1; dir++) {
                visited[start][dir] = true;
                min = Math.min(min, dfs(visited, start, min, edges[start].length, start));
                visited[start][dir] = false;
            }
        }
        return min;
    }
    public static int dfs(boolean[][] visited, int start, int min, int value, int line) {
        if(value >= min) {
            return min;
        }
        if(line == start && visited[line][0] && visited[line][1]) {
            return value;
        }
        for(int dir = 0; dir <= 1; dir++) {
            if(!((line != start) ? !visited[line][dir] : visited[line][dir])) {
                continue;
            }
            visited[line][dir] = true;
            for(int neighbor : edges[line].sets.get(dir)) {
                int neighborDir = edges[line].sets.get(0).contains(neighbor) ? 0 : 1;
                if(visited[neighbor][neighborDir]) {
                    continue;
                }
                visited[neighbor][neighborDir] = true;
                min = Math.min(min, dfs(visited, start, min, (neighbor != start) ? edges[neighbor].length + value : value, neighbor));
                visited[neighbor][neighborDir] = false;
            }
            visited[line][dir] = false;
        }
        return min;
    }
    public static class Edge {
        int length;
        List<Set<Integer>> sets = new ArrayList<Set<Integer>>();
        /**
         * initialize Edge in tree
         * @param length    length of Edge
         * @param l Edges in one dir
         * @param r Edges in the other dir
         */
        public Edge(int length, Set<Integer> l, Set<Integer> r) {
            this.length = length;
            sets.add(l);
            sets.add(r);
        }
    }
}
